+++
title = "Reverse-Engineering Earth Engine's Random Visualizer"
tags = ["earth-engine", "algorithms", "python"]
description = "Recreating a closed-source procedural color generation function through trial and error."
date = "2025-02-05"
+++

The `randomVisualizer` method in Earth Engine assigns randomized colors to unique values in an image, providing a quick and dirty method for visualizing classified pixels without having to manually create a color palette. 

{{<figure src="corine.png" caption="Before and after applying color to a land cover map with `randomVisualizer`.">}}

The method's convenience comes with some limitations. Because the palette is computed on-the-fly and applied directly to the image, the only way to know which colors are assigned to which values is to manually or programmatically sample the generated image, which makes some simple things like building legends pretty expensive.

We could predict palettes ahead of time if we knew how `randomVisualizer` assigns colors, but the server code is closed-source and the documentation just calls it "random". However, with a few reasonable assumptions and a lot of trial and error, maybe we can reverse-engineer our own version of the random visualizer. 

The only way to begin is by beginning.

## How Does it Work?

At its core, the Earth Engine RV (random visualizer) is a function that takes a number as input and returns 3 bytes representing red, green, and blue components. How? After some brainstorming and [research](https://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/), I settled on four likely algorithms:

1. A random number generator
1. A lookup table
1. A color transformation
1. A hash function

I'll take a closer look at each of those approaches, but first...

### Sample Outputs

I wrote a quick script to sample a few thousand unique input-output pairs from the Earth Engine RV, which I'll use to 1) look for patterns that might reveal the underlying algorithm and 2) validate candidate RV functions.

{{<figure src="swatches.png" caption="The first 100 positive integral color outputs from `randomVisualizer`.">}}

Running this script twice generates the same output, which reveals the first big clue: `randomVisualizer` is **deterministic** - a input value of 0 always returns `#fc2a85` <span style="color: #fc2a85">â–ˆ</span>.

That rules out the possibility of a purely random RGB or HSV color generator, leaving three more options.

### What About...

1. ~A random number generator~
1. **A lookup table**
1. A color transformation
1. A hash function

A pre-computed hash map of number-color pairs would be deterministic, fast[^lookup], and would give you full control to create a color palette that is perceptually distinct, colorblind-friendly, etc. The downsides are a finite palette that repeats at a fixed interval, and having to deal with out-of-range and floating-point lookups[^float] by wrapping or rounding to the nearest key.

Looking at the sampled outputs, there are **no repeating colors** with integer inputs between -1,000 and 1,000. 

{{<figure src="longitude.png" caption="Several thousand unique colors generated from sequential inputs.">}}

On top of that, floats return distinct colors to an arbitrary number of decimal places (i.e. 0.000001 and 0.000002 return different colors), suggesting **lookups aren't rounded**.

It's safe to say this isn't a lookup table with millions of unique entries, so let's check that off the list of possibilities.

### Maybe It's...

1. ~A random number generator~
1. ~A lookup table~
1. **A color transformation**
1. A hash function

Another strategy for procedurally generating deterministic color palettes is to apply a consistent transformation scaled by the input value, e.g. offsetting the hue with the golden ratio. This should be visible as a repeating pattern in the output color. 

Looking at the first 1,000 colors generated by the Earth Engine RV turned up **no repeating patterns** in RGB or HSV space, which you'd expect to see with a linear transformation.

{{<figure src="hues.png" caption="Hues generated by a golden ratio transformation (left) and by `randomVisualizer` (right).">}}

That just leaves one option.

### It Must Be...

1. ~A random number generator~
1. ~A lookup table~
1. ~A color transformation~
1. **A hash function**

An algorithm that converts arbitrary inputs to deterministic, non-repeating outputs sounds a *lot* like a hash function. I started encoding test values into bytes and feeding them into popular hash functions like MD5, SHA1, and SHA256, but failed to match any Earth Engine outputs.

There's no such thing as "almost right" with a hash function, since similar inputs hash to dissimilar outputs by design, so after exhausting every option in Python's built-in `hashlib` package, I wasn't any closer to knowing whether my mismatched outputs were the result of a subtle difference like mismatched binary endianness, or using the wrong hash function altogether.

Heck, maybe it's not even a hash function. That's when I found...

### The Breakthrough

On a whim, I Googled the RGB output (252, 42, 133) for an input value of 0 and found...

{{<figure src="murmurhash3.png">}}

...[`murmurhash3`](https://github.com/yihleego/murmurhash3), a Go library implementing a hash function that I haven't tried yet called [MurmurHash](https://en.wikipedia.org/wiki/MurmurHash). The project readme gives the following code example:

```go
murmur := murmur3.New32()
h := murmur.HashInt(0)

h.AsBytes() // {252, 42, 133, 99}
```

That's an input value of 0 mapping to the exact RGB output (ignoring the fourth byte) generated by the Earth Engine RV. Coincidence? I set up a quick Go project, ran some tests, and sure enough we can accurately reproduce output colors from arbitrary inputs.

Mystery solved! ðŸŽ‰

## A Python Random Visualizer

With some careful byte encoding and decoding, I was able to get a compatible MurmurHash implementation running in Python via the [`mmh3`](https://github.com/hajimes/mmh3) package.

```python
import mmh3
import struct

def murmur_hash(x: float | int) -> bytes:
    """Generate 3-byte hashes consistent with ee.Image.randomVisualizer."""
    # Encode to 64-bit (double or long long) little-endian
    fmt = "<d" if isinstance(x, float) else "<q"
    encoded = struct.pack(fmt, x)

    # Return the first 3 bytes of the hashed 32-bit int
    return struct.pack("<i", mmh3.hash(encoded))[:3]
```

Testing against all 2,000 sampled values from Earth Engine confirms this is a byte-accurate recreation of `randomVisualizer`, and we can even vectorize the hash function to create a fully functional local implementation of the method to apply to Numpy image arrays.

```python
import numpy as np

def random_visualizer(img: np.ndarray) -> np.ndarray:
    """Convert unique values in an image to deterministic RGB colors."""
    return np.vectorize(
        lambda x: np.array(tuple(murmur_hash(x))), 
        signature="()->(k)"
    )(img)
```

And just like that, there's one fewer black box in Earth Engine.

[^float]: Since it's designed for classified imagery that's almost exclusively integral, I was surprised to find that `randomVisualizer` does work with floating point inputs.

[^lookup]: Hashmap lookups are [usually O(1) in Java](https://stackoverflow.com/questions/4553624/hashmap-get-put-complexity).
